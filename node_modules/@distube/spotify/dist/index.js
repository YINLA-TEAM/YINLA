"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  SpotifyPlugin: () => SpotifyPlugin,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_spotify_uri = require("spotify-uri");
var import_isomorphic_unfetch = __toESM(require("isomorphic-unfetch"));
var import_spotify_url_info = __toESM(require("spotify-url-info"));
var import_spotify_web_api_node = __toESM(require("spotify-web-api-node"));
var import_distube = require("distube");
var SUPPORTED_TYPES = ["album", "playlist", "track", "artist"];
var API = new import_spotify_web_api_node.default();
var spotify = (0, import_spotify_url_info.default)(import_isomorphic_unfetch.default);
var expirationTime = 0;
var isTruthy = /* @__PURE__ */ __name((x) => Boolean(x), "isTruthy");
var refreshAPIToken = /* @__PURE__ */ __name(async () => {
  if (expirationTime <= Date.now() - 6e4) {
    const res = await API.refreshAccessToken().catch(() => API.clientCredentialsGrant());
    expirationTime = Date.now() + res.body.expires_in * 1e3;
    API.setAccessToken(res.body.access_token);
  }
}, "refreshAPIToken");
var getItems = /* @__PURE__ */ __name(async (data) => {
  if (data.trackList) {
    data.tracks = {
      items: data.trackList.map((track) => ({
        type: "track",
        name: track.title,
        artists: [{ name: track.subtitle }]
      }))
    };
    if (data.trackList.length > 90) {
      data.tracks.next = true;
      data.tracks.limit = 90;
      data.tracks.offset = 0;
      data.tracks.items.splice(90);
    }
  }
  if (!data.tracks.items)
    return data.tracks;
  const items = data.tracks.items;
  if (!["playlist", "album"].includes(data.type))
    return items;
  while (data.tracks.next) {
    if (!expirationTime)
      break;
    await refreshAPIToken();
    try {
      data.tracks = (await API[data.type === "playlist" ? "getPlaylistTracks" : "getAlbumTracks"](data.id, {
        offset: data.tracks.offset + data.tracks.limit,
        limit: 100
      })).body;
    } catch (e) {
      process.emitWarning(`${e?.body?.message}`, "SpotifyApi");
      process.emitWarning("There is a Spotify API error, max songs of Spotify playlist is 100.", "SpotifyPlugin");
      break;
    }
    items.push(...data.tracks.items);
  }
  return items;
}, "getItems");
var getAPI = /* @__PURE__ */ __name((method, ...args) => API[method](...args).then((r) => r.body), "getAPI");
var getDataWithAPI = /* @__PURE__ */ __name(async (url) => {
  const parsedURL = (0, import_spotify_uri.parse)(url);
  let data;
  const id = parsedURL.id;
  if (!id)
    throw new import_distube.DisTubeError("SPOTIFY_PLUGIN_UNSUPPORTED_LINK", "This link is not supported.");
  await refreshAPIToken();
  try {
    switch (parsedURL.type) {
      case "track":
        data = await getAPI("getTrack", id);
        break;
      case "album":
        data = await getAPI("getAlbum", id);
        data.tracks = await getAPI("getAlbumTracks", id, { limit: 50 });
        break;
      case "artist":
        data = await getAPI("getArtist", id);
        data.tracks = (await getAPI("getArtistTopTracks", id, "US")).tracks;
        break;
      case "playlist":
        data = await getAPI("getPlaylist", id);
        data.tracks = await getAPI("getPlaylistTracks", id, { limit: 100 });
        break;
      default:
        throw new import_distube.DisTubeError("SPOTIFY_PLUGIN_UNSUPPORTED_TYPE", "This type is not supported.");
    }
  } catch (error) {
    throw new import_distube.DisTubeError("SPOTIFY_PLUGIN_API_ERROR", error?.body?.error?.message || error.message || error);
  }
  return data;
}, "getDataWithAPI");
var SpotifyPlugin = class extends import_distube.CustomPlugin {
  constructor(options = {}) {
    super();
    __publicField(this, "parallel");
    __publicField(this, "emitEventsAfterFetching");
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new import_distube.DisTubeError("INVALID_TYPE", ["object", "undefined"], options, "SpotifyPluginOptions");
    }
    (0, import_distube.checkInvalidKey)(options, ["parallel", "emitEventsAfterFetching", "api"], "SpotifyPluginOptions");
    this.parallel = options.parallel ?? true;
    if (typeof this.parallel !== "boolean") {
      throw new import_distube.DisTubeError("INVALID_TYPE", "boolean", this.parallel, "SpotifyPluginOptions.parallel");
    }
    this.emitEventsAfterFetching = options.emitEventsAfterFetching ?? false;
    if (typeof this.emitEventsAfterFetching !== "boolean") {
      throw new import_distube.DisTubeError(
        "INVALID_TYPE",
        "boolean",
        this.emitEventsAfterFetching,
        "SpotifyPluginOptions.emitEventsAfterFetching"
      );
    }
    API.setAccessToken("");
    if (options.api !== void 0 && (typeof options.api !== "object" || Array.isArray(options.api))) {
      throw new import_distube.DisTubeError("INVALID_TYPE", ["object", "undefined"], options.api, "api");
    } else if (options.api) {
      if (typeof options.api.clientId !== "string") {
        throw new import_distube.DisTubeError("INVALID_TYPE", "string", options.api.clientId, "SpotifyPluginOptions.api.clientId");
      }
      if (typeof options.api.clientSecret !== "string") {
        throw new import_distube.DisTubeError(
          "INVALID_TYPE",
          "string",
          options.api.clientSecret,
          "SpotifyPluginOptions.api.clientSecret"
        );
      }
      API.setClientId(options.api.clientId);
      API.setClientSecret(options.api.clientSecret);
      API.clientCredentialsGrant().then((data) => {
        expirationTime = Date.now() + data.body.expires_in * 1e3;
        API.setAccessToken(data.body.access_token);
      }).catch((e) => {
        console.error(e);
        console.warn("[SpotifyPlugin]: Cannot get Spotify access Token from your api info. Disabled API feature!");
      });
    }
  }
  async validate(url) {
    if (typeof url !== "string" || !url.includes("spotify"))
      return false;
    try {
      const parsedURL = (0, import_spotify_uri.parse)(url);
      if (!parsedURL.type || !SUPPORTED_TYPES.includes(parsedURL.type))
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  async play(voiceChannel, url, options) {
    const DT = this.distube;
    const data = await spotify.getData(url).catch(() => {
      if (!expirationTime) {
        throw new import_distube.DisTubeError(
          "SPOTIFY_PLUGIN_UNKNOWN_EMBED",
          "Couldn't parse this embed link. Please provide Spotify API credentials as a backup."
        );
      }
      return getDataWithAPI(url);
    });
    const { member, textChannel, skip, position, metadata } = Object.assign({ position: 0 }, options);
    if (data.type === "track") {
      const query = `${data.name} ${data.artists.map((a) => a.name).join(" ")}`;
      const result = await this.search(query);
      if (!result)
        throw new import_distube.DisTubeError("SPOTIFY_PLUGIN_NO_RESULT", `Cannot find "${query}" on YouTube.`);
      await DT.play(voiceChannel, result, options);
    } else {
      const name = data.name;
      const thumbnail = (data.coverArt?.sources || data.images)?.[0]?.url;
      const queries = (await getItems(data)).map((item) => {
        const track = item.track || item;
        if (track.type !== "track")
          return null;
        return `${track.name} ${track.artists.map((a) => a.name).join(" ")}`;
      }).filter(isTruthy);
      let firstSong;
      const getFirstSong = /* @__PURE__ */ __name(async () => {
        const firstQuery = queries.shift();
        if (!firstQuery)
          return;
        const result = await this.search(firstQuery);
        if (!result)
          return;
        firstSong = new import_distube.Song(result, { member, metadata });
      }, "getFirstSong");
      while (!firstSong)
        await getFirstSong();
      if (!firstSong) {
        throw new import_distube.DisTubeError("SPOTIFY_PLUGIN_NO_RESULT", `Cannot find any tracks of "${name}" on YouTube.`);
      }
      const queue = DT.getQueue(voiceChannel);
      const playlistInfo = {
        source: "spotify",
        songs: [firstSong],
        name,
        thumbnail,
        member,
        url
      };
      const playlist = new import_distube.Playlist(playlistInfo, { member, metadata });
      const fetchTheRest = /* @__PURE__ */ __name(async (q, fs) => {
        if (queries.length) {
          let results = [];
          if (this.parallel) {
            results = await Promise.all(queries.map((query) => this.search(query)));
          } else {
            for (let i = 0; i < queries.length; i++) {
              results[i] = await this.search(queries[i]);
            }
          }
          playlist.songs = results.filter(isTruthy).map((r) => {
            const s = new import_distube.Song(r, { member, metadata });
            s.playlist = playlist;
            return s;
          });
          q.addToQueue(playlist.songs, !skip && position > 0 ? position + 1 : position);
        }
        playlist.songs.unshift(fs);
      }, "fetchTheRest");
      if (queue) {
        queue.addToQueue(firstSong, position);
        if (skip)
          queue.skip();
        else if (!this.emitEventsAfterFetching)
          DT.emit("addList", queue, playlist);
        await fetchTheRest(queue, firstSong);
        if (!skip && this.emitEventsAfterFetching)
          DT.emit("addList", queue, playlist);
      } else {
        let newQueue = await DT.queues.create(voiceChannel, firstSong, textChannel);
        while (newQueue === true) {
          await getFirstSong();
          newQueue = await DT.queues.create(voiceChannel, firstSong, textChannel);
        }
        if (!this.emitEventsAfterFetching) {
          if (DT.options.emitAddListWhenCreatingQueue)
            DT.emit("addList", newQueue, playlist);
          DT.emit("playSong", newQueue, firstSong);
        }
        await fetchTheRest(newQueue, firstSong);
        if (this.emitEventsAfterFetching) {
          if (DT.options.emitAddListWhenCreatingQueue)
            DT.emit("addList", newQueue, playlist);
          DT.emit("playSong", newQueue, firstSong);
        }
      }
    }
  }
  async search(query) {
    try {
      return (await this.distube.search(query, { limit: 1 }))[0];
    } catch {
      return null;
    }
  }
};
__name(SpotifyPlugin, "SpotifyPlugin");
var src_default = SpotifyPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SpotifyPlugin
});
//# sourceMappingURL=index.js.map